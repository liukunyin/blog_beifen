---
title: 操作系统大纲
top: false
cover: false
img: /medias/featureimages/12.jpg
toc: true
mathjax: true
date: 2019-10-04 16:48:26
summary: 操作系统大纲
tags: 学习记录
categories: 操作系统
---
## 一、概要

### 第一章 操作系统引论（缺失）
* 分时实时系统比较
* 操作系统特征和功能
* 微内核系统

### 第二章 进程的描述与控制
* 了解前趋图进程的基本概念（题解p17）和应用；
* 理解程序执行，并发执行的概念、特点，以及并发执行的条件；题解p17
* 熟悉进程的基本概念、特征、pcb、进程实体、进程状态及其转换，熟悉进程与程序的关系；
* 了解线程的基本概念，线程的调度管理，以及与进程的关系；
* 了解进程同步和线程通信的基本概念；
* 了解进程通信的基本类型、特点和要求；
* 理解临界资源、临界区，以及同步准则等概念的基本含义，具体要求和进本应用；
* 了解常见的信号量机制，理解其基本原理和要求，能正确选用他们解决实际应用问题；

### 第三章 处理机调度与死锁
* 了解处理机调度的基本概念及调度准则，掌握低级调度的主要功能；
* 掌握处理机调度的基本算法，及其应用；
* 掌握实时系统的调度算法，及其应用；
* 理解死锁的基本概念，死锁产生的原因和必要条件，以及处理死锁的基本方法，死锁定理；
* 了解预防死锁的基本方法，掌握银行家算法及安全性算法；

***

## 二、重点课后题

### 第一章
#### 10.试从交互性、及时性以及可靠性方面将分时系统与实时系统进行比较
1）交互性：分时系统是一种通用系统，主要用于运行终端用户程序，因而它具有较强的交互能力；而实时系统虽然也有交互能力，但这里人与系统的交互仅限于访问系统中某些特定的专用服务程序，其交互能力不及前者
2）及时性：实时信息系统对及时性的要求与分时系统类似，都是以人所能接受的等待时间来确定；而实时控制系统的及时性则是以控制对象所要求的开始截止时间和完成截止时间来确定的，一般为秒级到毫秒级。
3）可靠性：分时系统虽然也要求系统可靠，但相比之下，实时系统对系统的可靠性要求要比分时系统对系统的可靠性要求高
#### 11.OS有哪几大特征？其最基本的特征是什么？
井发性、共享性,虚拟性和异步性四个基本特征; 最基本的特征是并发性。
#### 21.微内核操作系统有哪些优点？它为何能有这些优点？
1）提高了系统的可扩展性
2）增强了系统的可靠性
3）可移植性强
4）提供了对分布式系统的支持
5）融入了面向对象技术
原因：微内核os结构是建立在模块化，层次化结构基础上的，并且采用了客户/服务器模式和面对对象的程序设计技术。

### 第二章
#### 6.进程与程序的主要区别和关系
1）程序是指令的集合，本身没有任何运行的含义，是一个静态概念；而进程是程序在处理机上的一次执行过程，是一个动态概念。
2）程序的存在是永久的；而进程是有生命周期的，它因创建而产生，因调度而执行，因缺少资源而暂停，因撤消而消亡。
3）程序仅是指令的有序集合；而进程则由程序段、数据段、进程控制块组成。
4）进程与程序之间不是一一对应的，即同一程序可同时运行于若干个不同的数据集合上，它将属于不同的进程：而一个进程也可以执行多个程序。
#### 10.pcb的作用是什么为什么说pcb是进程存在的唯一标志
&emsp;&emsp;进程控制块是操作系统用来描述和管理进城的数据结构，其作用是使一个在多道程序环境下，不能独立运行的程序，成为一个能独立运行的基本单位，即一个能与其他进程并发执行的进程。
&emsp;&emsp;在创建进程时，系统将为他配置一个PCB，在进程调度时，系统将根据PCB的状态和优先级等信息来选择新进程，然后将老进程的现场信息保存到它的PCB中，再根据 新进程PCB中所保存的处理机状态信息来恢复运行的现场；执行中的进程，如果需要访问文件或者需要与合作进程实现同步或通信，也都需要访问PCB；当进程因某种原因而暂停执行时，也必须将断点的现场信息保存到它的PCB中：当进程结束时，系统将回收它的PCB，可见，在进程的整个生命期中，系统总是通过其PCB对进程进行控和管理，亦即，系统是根据其PCB而不是任何别的什么而感知到进程的存在，所以说，PCB是进程存在的唯一标志。
#### 21.试从调度性、并发性、拥有资源、独立性、系统开销、及对多处理机的支持等方面，对进程和线程进行比较。
1）调度性。在传统的操作系统中，拥有资源的基本单位、独立调度和分派的基本单位都是进程。而在引入线程的OS中，则是把线程作为调度和分配的基本的单位，进程只是拥有资源的基本单位，而不再是调度和分派的基本单位。
2）并发性。在引入线程的OS中，不仅进程间可以并发执行，而且在一个进程内的多个线程间，也可以并发执行，因而比传统的OS具有更好的并发行。
3）拥有资源。在这两种OS中，拥有资源的基本单位都是进程。线程除了一点在在运行中必不可少的资源（如线程控制块、程序计数器、一组寄存器值和堆栈）外，本身基本不拥有系统资源，但它可共享其隶属的进程的资源。
4）独立性。每个进程都能独立地申请资源和独立的运行；但同一进程的多个线程则共享进程的内存地址空间和其他资源，它们之间的独立性比进程之间的独立性要低。
5）开销。由于创建和撤消进程时，系统都要为之分配和回收资源，如内存空间等。进程切换时所要保存和设置的现场信息也要明显地多于线程，因此，OS在创建、撤销和切换进程时
所付出的开销显著大于线程。另外由于隶属于同一个进程的多个线程共享同一地址空间和打开文件，从而使它们之间的同步和通信的实现也变得更为容易。
6）支持多处理机系统。传统的进程，只能运行在一个处理机上；多线程的进程，则可以将进程中的多个线程分配到多个处理机上，从而获得更好的并发执行效果。

***
#### 补充
#### 1.进程的三种基本状态
就绪状态、执行状态、阻塞状态。
#### 2.临界区、临界资源定义
临界资源：一段时间内只允许一个进程访问。
临界区：进程中访问临界资源的那段代码称为临界区
#### 3.同步准则
空闲让进、忙则等待、有限等待、让权等待

### 第三章
#### 7.试说明低级调度的主要功能
1）保存处理机的现场信息
2）按某种算法选取进程
3）把处理机分配给进程
#### 12.试比较FCFS和SPF两种进程调度算法
相同点：两种调度算法都可以用于作业调度和进程调度
不同点：FCFS调度算法每次都从后备队列中选择一个或多个最先进入该队列的作业，将他们调入内存、分配资源、创建进程、插入到就绪队列。该算法有利于长作业/进程，不利于短作业/进程。SPF算法每次调度都从后备队列中选择一个或若干个估计运行时间最短的作业，调入内存中运行。该算法有利于短作业/进程，不利于长作业/进程
#### 15.为什么说多级反馈队列调度算法能较好地满足各方面用户的需求？
1）终端型作业用户提交的作业大多属于较小的交互型作业，系统只要提交这些作业在第一队列规定的时间片内完成，终端作业用户就会感到满足。
2）短批处理作业用户，开始时像终端型作业一样，如果在第一队列中执行一个时间片段即可完成，便可获得与终端作业一样的响应时间。对于稍长作业，通常只需在第二和第三队列各执行一时间片即可完成，其周转时间仍然较短。
3）长批处理作业，他将依次在第1，2，。。。，n个队列中运行，然后再按轮转方式运行，用户不必担心其长期作业得不到处理。所以，多级反馈队列调度算法能满足更多用户需求。
#### 27.何谓死锁？产生死锁的原因和必要条件是什么？
定义：如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的
产生原因：1）竞争资源。2）进程推进顺序非法。
必要条件：1）互斥条件。2）请求和保持条件。3）不可抢占条件。4）循环等待条件。
#### 30.银行家算法的例子中，如果P0发出的请求向量由Request（0，2，0）改为Request（0，1，0），问系统可否将资源分配给它？
能分配
request（0，1，0）≤need（7，4，3）；
request（0，1，0）≤available（2，3，0）；
系统暂时假定可为P0分配资源，并修改有关数据，如下所示：

|        |allocation|need|available
| ---- | ---- | ---- | ---- |
|        |A  B  C|A  B  C|A  B  C
p0|0  2  0|7  3  3|2  2  0
p1|3  0  2|0  2  0|
p2|3  0  2|6  0  0|
p3|2  1  1|0  1  1|
p4|0  2  2|4  3  1|

利用安全性算法检查

|        |work|need|allocation|work+allocation|finish
| ---- | ---- | ---- | ---- | ---- | --- |
| |A  B  C|A  B  C|A  B  C|A  B  C|
p1|2  2  0|0  2  0|3  0  2|5  2  2|true
p3|5  2  2|0  1  1|2  1  1|7  3  3|true
p0|7  3  3|7  3  3|0  2  0|7  5  3|true
p2|7  5  3|6  0  0|3  0  2|10 5  5|true
p4|10 5  5|4  3  1|0  0  2|10 5  7|true

存在安全序列{p1,p3,p0,p2,p4}所以能分配
#### 31.在银行家算法中，若出现下述资源分配情况，试问：

|process|allocation|need|available
| ---- | ---- | ---- | ---- |
p0     |0 0 3 2|0 0 1 2|1 6 2 2
p1     |1 0 0 0|1 7 5 0|
p2     |1 3 5 4|2 3 5 6|
p3     |0 3 3 2|0 6 5 2|
p4     |0 0 1 4|0 6 5 6|

（1）该状态是否安全？

|        |work|need|allocation|work+allocation|finish
| ---- | ---- | ---- | ---- | ---- | --- |
p0|1 6 2 2|0 0 1 2|0 0 3 2|1 6 5 4|true
p3|1 6 5 4|0 6 5 2|0 3 3 2|1 9 8 6|true
p4|1 9 8 6|0 6 5 6|0 0 1 4|1 9 9 10|true
p1|1 9 9 10|1 7 5 0|1 0 0 0|2 9 9 0|true
p2|2 9 9 10|2 3 5 6|1 3 5 4|3 12 14 14|true

存在安全序列{p0,p3,p4,p1,p2}所以安全
（2）p2发出请求向量Request（1，2，2，2）后，系统能否将资源分配给它？
系统按银行家算法进行检查：
①request2（1，2，2，2）≤need2（2，3，5，6）
②request2（1，2，2，2）≤available（1，6，2，2）
③系统先假定可为P2分配资源并修改
available = （0，4，0，0）
allocation2 = （2，5，7，6）
need2 = （1，1，3，4）
④进行安全性检查：此时对所有的进程need≤available都不成立故系统进入不安全状态。
因此不能分配给P2
